<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
  <head>
   <title>SWISH-Enhanced:  Proposed changes for SWISH-E 3.0 </title>
   <link href="./style.css" rel=stylesheet type="text/css" title="refstyle">
  </head>
  <body>

    <h1 class="banner">
        <img src="images/swish.gif" alt="Swish-E Logo"><br>
        <img src="images/swishbanner1.gif"><br>
        <img src="images/dotrule1.gif"><br>
         Proposed changes for SWISH-E 3.0 
    </h1>

    <hr>

    <p>
    <div class="navbar">
      <a href="./SWISH-PERL.html">Prev</a> |
      <a href="./index.html">Contents</a> |
      <a href="./CHANGES.html">Next</a>
    </div>
    <p>

    <div class="toc">
      
<A NAME="toc"></A>
<P><B>Table of Contents:</B></P>

<UL>

	<LI><A HREF="#Overview">Overview</A>
	<LI><A HREF="#Move_from_inverted_index_to_a_da">Move from inverted index to a data base</A>
	<LI><A HREF="#Index_and_Sort_Numbers">Index and Sort Numbers</A>
	<LI><A HREF="#Switch_to_Content_Types">Switch to Content-Types</A>
	<LI><A HREF="#Document_Source_Feature">Document Source Feature</A>
	<LI><A HREF="#Fast_Filters">Fast Filters</A>
	<LI><A HREF="#Convert_all_Meta_data_to_Meta_Na">Convert all Meta data to Meta Names</A>
	<LI><A HREF="#Document_Info">Document Info</A>
</UL>

    </div>

    

	    [ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>

<P>
<H1><A NAME="Overview">Overview</A></H1>
<P>
This pages is intended to give users of SWISH-E an idea of the changes to
come, to foster discussion of the direction of SWISH-E, and a place where
developers can map out new ideas.

<P>
Most of this is just random notes that should be cleaned up!

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H1><A NAME="Move_from_inverted_index_to_a_da">Move from inverted index to a data base</A></H1>
<P>
Jose:

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H1><A NAME="Index_and_Sort_Numbers">Index and Sort Numbers</A></H1>
<P>
Jose:

<P>
(Moseley: Dec 29, 2000)

<P>
I think this would be a great feature -- it would be nice be able to
specify which tags are numeric. Something like:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    MetaNames subject title name age
    PropertyNames name age
    NumericNames age</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Then be able to select a range of numbers in a search, and sort numerically
is the tag is also a property.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H1><A NAME="Switch_to_Content_Types">Switch to Content-Types</A></H1>
<P>
Moseley: Dec 28, 2000

<P>
I'm wondering if it might be smart to switch from the current ``Document
Types'' to Content-Types. Currently, swish know how to parse three types of
documents TXT, HTML, and XML. There's currently a new configuration
directives DefaultContents and IndexContents that map file extensions to
one of the three types. This doesn't really work when spidering since it's
the content-type that describes the document and not the file extension.

<P>
It's an issue that can wait, but I'm concerned about backward compatiblity
before people start using the IndexContents and DefaultContents config
directives and then we change to content-type in the future. There's
probably not that many people using those, but it might be work noting in
the documentation that it will change, if we agree.

<P>
The main reason to use content-type instead is for http processig where you
can't depend on the file extension to determine the document type, so with
http we have to use content-type to determine how to deal with the file.
The other reason to changes it is to break down the differences between
http and file system modes of indexing.

<P>
This would, of course, lead to other issues -- like dealing with IndexOnly
so that it might be a big enough change that it also needs to wait until a
later version (version 3.0?). But it should be something we think about,
and make note of in the documentation.

<P>
Again, I'd propose that swish uses a mime.types file to map from extension
to content-type. You could add or override mappings in the config file:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>   AddType text/plain .doc .log</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>   DefaultType text/html  # like DefaultContents currently</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The file source ``plug-in'' (whatever that ends up being) would return a
content-type, but if not returned then swish would map the type from the
file name using the mime.types file or any AddType directives.

<P>
Again, internally swish only knows about text/[TXT|HTML|XML], so there
should be a way to map other types, otherwise swish might ignore the file.
We could continue to use the three type names or switch completely to
content-types.

<P>
For example, if we continued to use [TXT|HTML|XML]

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    MapType TXT  text/directory text/logfile
    MapType HTML text/html</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Would tell swish that those types are handled by those internal handlers.

<P>
Then as I've mentioned before, you might specify filters as such

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>   FilterDocument application/msword /path/to/word-to-text</pre>
        </td>
	    
      </tr>
    </table>
    <P>
And word-to-text would convert to text and return one of the three
content-types that Swish knows how to parse, or a different content type if
were to chain filters.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H1><A NAME="Document_Source_Feature">Document Source Feature</A></H1>
<P>
Moseley: Dec 28, 2000

<P>
First, I'd like to see the http part of swish moved out of the program, and
instead design a fast way for external programs to provide documents to
swish. Spidering is too complicated to be done internally, and is not
really what swish does at its core. No doubt that the swish package should
provide spidering, but in a different way.

<P>
So, I'd like to be able to specify to swish a program, and that program
returns the documents to swish to index, just as if swish was accessing the
documents via http. For example, the program would return headers followed
by the document content.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    File-Name: docs/index.html
    Last-Modified: Fri, 22 Dec 2000 01:07:19 GMT
    Content-Length: 10483
    Content-Type: text/html
    &lt;blank line&gt;
    &lt;document contents&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This could be any program -- one that spiders a number of servers at the
same time, or one that uncompresses local files before passing to swish.

<P>
Then the IndexDir command would list directories and/or files, and if a
file is an exectable program then swish runs and accepts documents from
that program.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    # Index /usr/doc and spider our other server
    IndexDir /usr/doc /usr/local/bin/swish-spider</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The program could be passed the path to the current configuration file
swish is using.

<P>
(BTW -- It might be nice to be able to say don't recurse directories:
/usr/doc recurses where /usr/doc/ doesn't recurse. Now that would be
confusing!)

<P>
Also <STRONG>NoContents</STRONG> could use content-types and not be limited to just the file system indexing
mode.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    NoContents image/gif
    </pre>
        </td>
	    
      </tr>
    </table>
    <P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H1><A NAME="Fast_Filters">Fast Filters</A></H1>
<P>
Moseley: Dec 28, 2000

<P>
Find a way to create filtrers that can act as servers and be left in
memory. Leave the current filter system in place for smaller indexes. Using
sockets may be the most portable method. Could provide a perl module to
make it simple to create filters.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    FilterDocument  /path/to/filter application/gzip application/zip</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Any documents that are returned to swish of those content-types would be
passed to the filter program. The protocol would look a lot like http,
where swish sends headers and content, and returns headers and content. The
content could be passed onto other filters. If the content-type returned
matches one of the MapType assigned content types then the swish internal
parser would accept the document for indexing. Perhaps the FilterDocument
directive would be listed in order to allow chaining, but prevent loops.

<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H1><A NAME="Convert_all_Meta_data_to_Meta_Na">Convert all Meta data to Meta Names</A></H1>
<P>
Moseley: Jan 1, 2001

<P>
Swish currently returns a file name, file size (or content-length) in
search results. This is called <EM>Meta Data</EM>
as it's information about (or that describes) the document. There are and
will be new Meta Data added as time goes on. For example, the Last Modified
Date is currently being added to 2.1.

<P>
The problem with this is how to return this data in query results -- if the
standard output from swish-e changes with a new version that means any
program parsing the results must also be changed.

<P>
Swish 2.1 has an c&lt;-x&gt; switch to report <EM>extended</EM> output in search results, but again once someone starts to use -x in a CGI
script then that script will break if a new feature is added.

<P>
Currently in swish documents may contain meta tagged content:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    &lt;subjects&gt;
          Food | Drinks | Recipes
    &lt;/subjects&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    &lt;summary&gt;
        The art of making good food and drinks, and lists many recipies.
    &lt;/summary&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This is also Meta Data since it's information about the document.    

<P>
By using

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    MetaNames subjects summary</pre>
        </td>
	    
      </tr>
    </table>
    <P>
you can search for words or phrases just within those meta fields.

<P>
By also using

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    PropertyNames subjects summary</pre>
        </td>
	    
      </tr>
    </table>
    <P>
you can also return the contents of those meta tags in a search by using
the <CODE>-p</CODE> switch.

<P>
Search results may also be sorted by PropertyNames.

<P>
My proposal is to use the existing swish framework of <STRONG>MetaNames</STRONG> and <STRONG>PropertyNames</STRONG> to handle meta data that's currently available only in swish results (rank,
file name, file size). The difference is that we assign ``internal'' meta
names to this data.

<P>
For example, SWISH_FILENAME could the be meta name used for the name of the
file:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    MetaNames SWISH_FILENAME</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    swish-e -w SWISH_FILENAME=(html/index*)</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Or SWISH_LAST_MODIFIED_SEC could be used for sorting results

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    PropertyNames SWISH_LAST_MODIFIED_SEC category</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    swish-e -w foo -s category asc SWISH_LAST_MODIFIED_SEC desc</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If PropertyNames directive was enhanced to be able to limit the number of
characters stored, optionally extract text from HTML, and was able to
define what type of docs (text, XML, HTML) it applied to, then the existing
PropertyNames feature would work like the new StoreDescription feature but
be useful for more than just one use.

<P>
I'm not clear how to enhance the syntax of Properties and/or Metanames, but
here's some ideas:

<UL>
<P><LI>
<P>
to specify an upper limit on how many characters to store

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    PropertyNames meta1 desc:50</pre>
        </td>
	    
      </tr>
    </table>
    <P>
That gets all of meta1 and only 50 chars of desc.    

<P><LI>
<P>
to limit to certain types of files

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    PropertyNames meta1 desc:50/HTML summary/XML</pre>
        </td>
	    
      </tr>
    </table>
    <P><LI>
<P>
to extract the text from html (remove html tags)

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    PropertyNames desc:50/HTML:text</pre>
        </td>
	    
      </tr>
    </table>
    <P>
(ok, that's ugly, but you get the idea)

<P><LI>
<P>
to read text documents where there are not tags:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    PropertyNames  desc:50/HTML:text desc:50/TXT</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Where desc is a meta name invented for storing the first 50 chars of the
text files.

</UL>
<P>
Also, it might be <EM>nice</EM> to be able to <STRONG>alias</STRONG> meta names so that, say, XML and HTML could have differently named meta
tags associated with the same meta tag name.

<P>
I'm not clear the best way to make an alias: One way would be to extend the
current MetaName syntax:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    MetaNames meta1 meta2 meta2=desc:HTML meta2=summary:XML</pre>
        </td>
	    
      </tr>
    </table>
    <P>
So that swish-e -w meta2=(foo) would find foo in the desc meta tag in HTML
docs, and find foo in the &lt;summary&gt; <CODE>tag(sic)</CODE> in XLM
documents.

<P>
Or another way would be to create a new directive

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    AliasMeta meta2=desc:HTML,summary:XML meta3=subject:HTML,type:XML</pre>
        </td>
	    
      </tr>
    </table>
    <P>
But I like extending existing syntax than adding new syntax. Less chance
for errors and keeps settings together in the same place.    

<P>
The advantages of all this are:

<UL>
<P><LI>
<P>
new internal meta data tags can be added without having to change the
output from swish results and therefore without changing any CGIs

<P><LI>
<P>
uses existing code to implement, and existing interface to use

<P><LI>
<P>
user can decide which meta data to include in an index which might be
helpful for really large sites where index size is important

<P><LI>
<P>
can search by the meta data, just like existing &lt;meta&gt; tagged content

<P><LI>
<P>
can sort results by all meta data, not just &lt;meta&gt; tags in documents.

<P><LI>
<P>
can be used to implement the StoreDescription feature insead of creating a
new feature.

</UL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H1><A NAME="Document_Info">Document Info</A></H1>
<P>
$Id$

<P>
.

[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>



    <p>
    <div class="navbar">
      <a href="./SWISH-PERL.html">Prev</a> |
      <a href="./index.html">Contents</a> |
      <a href="./CHANGES.html">Next</a>
    </div>
    <p>

    <P ALIGN="CENTER">
    <IMG ALT="" WIDTH="470" HEIGHT="10" SRC="images/dotrule1.gif"></P>
    <P ALIGN="CENTER">

    <div class="footer">
        Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000 Hewlett-Packard Company<BR>
        Originally by Kevin Hughes, kev@kevcom.com, March 11, 1994.
        <BR>SWISH-E is distributed with <B>no warranty</B> under the terms of the <A 
        HREF="http://www.fsf.org/copyleft/gpl.html">GNU Public License</A>,<BR>
        Free Software Foundation, Inc., 
        59 Temple Place - Suite 330, Boston, MA  02111-1307, USA<BR> 
        Public questions may be posted to 
        the <A HREF="http://sunsite.berkeley.edu/SWISH-E/Discussion/">SWISH-E Discussion</A>.
    </div>

</body>
</html>
