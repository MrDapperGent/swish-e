#!@@perlbinary@@ -w
#!/usr/bin/speedy -w
package SwishAPISearch;
use strict;

######################################################################
# Skeleton CGI script for searching a Swsih-e index with SWISH::API.
# see below for documenation or run "perldoc search.cgi"
#
# Copyright 2003, 2004 Bill Moseley - All rights reserved.
#
# $Id$
#
#######################################################################

use vars '$VERSION';
$VERSION = '1.1';


# This needs to be set to where Swish-e installed the Perl modules 

# This is set to where Swish-e's "make install" installed the helper modules.
use lib qw( @@perlmoduledir@@ );

#------------------- Modules --------------------------------------
use SWISH::API;             # for searching the index file
use SWISH::ParseQuery;      # Parses the query string
use SWISH::PhraseHighlight; # for highlighting
use CGI;                    # provides a param() method -- could use Apache::Request, for example.
use HTML::FillInForm;       # makes the form elements sticky
use Template;               # Template-Toolkit: http://tt2.org or see http://search.cpan.org




#-------------------- Defaults/Parameters --------------------------
# Default config settings
#
# The expand_metas maps nested meta names -- that is, meta names that represent
# multiple metanames (search -w all=foo might really search title=foo and
# author=foo This expansion is only needed for highlighting

use vars qw/ %config %highlight_settings %site_cache /;

%config = (
    INCLUDE_PATH => '@@templatedir@@',  # template path
    index        => 'index.swish-e',             # path to index file
    page_size    => 10,                          # numbe of results/page
    title        => 'Swish Example Search Page',
    template     => 'search.tt',
    expand_metas => {
        swishdefault => [ qw/ swishtitle swishdefault / ],
    }
);


# Params used for the highlighting modules

%highlight_settings = (
    show_words      => 8,  # number of words to show
    occurrences     => 5,   # number of words to show
    max_words       => 100, # max number of words to show if not highlighted words found
    highlight_on    => '<span class="highlight">',
    highlight_off   => '</span>',
);

#--------------------- Code ----------------------------------------
# Entry point for normal CGI programs.
# Should be object creation

unless ( $ENV{MOD_PERL} ) {

    $site_cache{_singleton} ||= {
        config  => \%config,  # no deep copy
    };

    process_request( $site_cache{_singleton}  );
}


# Entry point for mod_perl
sub handler {
    my $r = shift;

    require Storable;

    my $id = $r->dir_config('site_id') || '_singleton';

    unless ( $site_cache{ $id } ) {

        $site_cache{ $id } ||= {
            config => Storable::dclone( \%config ), # deep copy
        };

        my $config =  $site_cache{ $id }{config};

        for ( qw/ INCLUDE_PATH index page_size title temmplate / ) {
            my $value = $r->dir_config( $_ );
            $config->{$_} = $value if defined $value;
        }
    }

    process_request( $site_cache{ $id } );

    return Apache::Constants::OK();
}



#-------------------------------------------------------------------
# Process a request
# Passes in a config hash
#-------------------------------------------------------------------


sub process_request {
    my ( $instance ) = @_;  # bad name since it persists between requests

    my $cgi = CGI->new;  # could also be Apache::Request or other fast access to CGI params

    my $config = $instance->{config};

    my $request = {
        cgi         => $cgi,
        myself      => $cgi->script_name,
        query       => $cgi->param('query') || undef,
        metaname    => $cgi->param('metaname') || undef,
        page        => $cgi->param('page') || 1,
        pagesize    => $cgi->param('size') || $config->{page_size} || 10,
        pid         => $$,
    };

    $instance->{request} = $request;


    # If a query was passed in then run the search
    if ( $request->{query} ) {

        #  Limit by metaname
        $request->{swish_query} = $request->{metaname}
            ? "$request->{metaname}=( $request->{query} )"
            : $request->{query};

        $instance->{result} = run_query( $instance );
    }


    # Generate output
    my $output = generate_view( $instance );


    # Run output through HTML::FillInForm to make form elements sticky

    my $fill_in_object = HTML::FillInForm->new;
    print $cgi->header;
    print $fill_in_object->fill( scalarref => $output, fobject => $cgi );

    delete $instance->{request};  # clean up the request
    delete $instance->{result};
}




# Subroutine to run the Swish query.  Returns a hash reference.
# A better design might be to return an object with methods for accessing the data.

sub run_query {
    my ( $instance ) = @_;

    my $config = $instance->{config};
    my $request = $instance->{request};

    my $page = $request->{page};
    my $pagesize = $request->{pagesize};

    $page = 1 unless defined $page  && $page =~ /^\d+$/;
    $pagesize = 15 unless defined $pagesize && $pagesize =~ /^\d+$/ && $pagesize > 0 && $pagesize < 50; 


    # Create the swish object if not cached.
    # Also read in the header data and initialize the highlighting module

    my $swish = $instance->{swish};

    if ( ! $swish ) {
        $swish = SWISH::API->new( $config->{index} );
        die "Failed to create SWISH::API object" unless $swish;
        $swish->AbortLastError if $swish->Error;

        $instance->{swish} = $swish;  # cache for next request or for template

        # Note, this only works with a single index file
        my %headers = map { lc($_) => ($swish->HeaderValue( $config->{index}, $_ )||'') } $swish->HeaderNames;

        # and cache the highlighting object
        $instance->{highlight_object} = SWISH::PhraseHighlight->new( \%highlight_settings, \%headers );
    }


    # Run the search.  See SWISH::API for more options (like sorting)

    my $results = $swish->Query( $request->{swish_query} );

    if ( $swish->Error ) {
        $swish->AbortLastError if $swish->CriticalError;
        return {
            message => join( ' ', $swish->ErrorString, $swish->LastErrorMsg ),
        };
    }

    return { hits  => 0 } unless $results->Hits;


    # Seek to the first record of the page requested

    $results->SeekResult( ($page-1) * $pagesize );

    if ( $swish->Error ) {
        $swish->AbortLastError if $swish->CriticalError;
        return {
            message => join( ' ', $swish->ErrorString, $swish->LastErrorMsg ),
        };
    }

    my @records;
    my $result;
    my $cnt = $pagesize;



    # Store the result objects in an array
    push @records, $result while $cnt-- && ($result = $results->NextResult);


    # Return the results structure

    my %result = (
        results_obj => $results,
        results     => \@records,
        hits        => $results->Hits,
        shown       => scalar @records,
        page        => $page,
        start       => ($page-1) * $pagesize,
    );




    $result{prev} = $page-1 if $page > 1;
    $result{next} = $page+1 if $result{start} + $pagesize < $result{hits};

    return \%result;
}


# This generates the output from the templates

sub generate_view{
    my ( $instance ) = @_;

    my $config = $instance->{config};
    my $result = $instance->{result};

    $instance->{template_object} ||= Template->new( INCLUDE_PATH => $config->{INCLUDE_PATH} ) 
        || die $Template::ERROR, "\n";

    my $template = $instance->{template_object};


    # Create a highlight filter if any results
    create_highlight_filter( $instance ) if $result->{hits};


    my $template_output;
    $template->process( $config->{template}, $instance, \$template_output ) || die $template->error;

    return \$template_output;

}

# Creates a filter for highlighting search terms

sub create_highlight_filter {
    my ( $instance ) = @_;

    my $result = $instance->{result};
    my $config = $instance->{config};


    # Now create a filter 'highlight' for use in the template to highlight terms
    # Usage requires passing in the *metaname* associated with the property
    # that's being highlighted -- this allows the program to know what
    # search words to use in highlighting 

    my $parsed_query = parse_query( join ' ', $result->{results_obj}->ParsedWords( $config->{index} ) );

    # Expand nested queries
    # A search for swishdefault or all might really include multiple tags
    # So expand the keywords to the extra fields
    #

    my $expand_metas = $config->{expand_metas};

    for my $meta ( keys %$expand_metas ) {
        next unless $parsed_query->{$meta};

        # Now duplicate
        # Push to merge any existing, for example is there was a query like:
        # -w all=foo AND title=bar  then title would end up with both
        # Not perfect


        for my $real_meta ( @{$expand_metas->{$meta}} ) {
            push @{ $parsed_query->{$real_meta} }, @{$parsed_query->{$meta}};
        }
    }

    # save for Data::Dumper
    $result->{parsed_query} = $parsed_query;

    # Now create the Template-Toolkit "filter"

    $instance->{template_object}->context->define_filter( 'highlight',
        sub {
            my ( $context,  $metaname ) = @_;

            # Grap parsed phrases based on metaname
            my $phrases = $parsed_query->{$metaname};


            return sub {
                my $text = shift;
                $instance->{highlight_object}->highlight( \$text, $phrases);
                return $text;
            }
        }, 

        1,
    );
}
__END__

=head1 NAME

search.cgi -- Example Perl program for searching with Swish-e and SWISH::API

=head1 DESCRIPTION

This is a very simple program that shows how to use the SWISH::API module
in a CGI script.  Unlike swish.cgi, this is suppose to not have many
built-in features.  So don't ask why it doesn't do something.  The
point is that this is used as a starting point that YOU customize.

This program is intended for programmers that want to create a custom
search script.

This program does require that some modules are installed from CPAN.
See REQUIREMENTS below for details and an explanation of why.

This program does not handle multiple index files, special metanames
that can be selected by drop-down boxes or anything else fancy.  Again,
the point is that this script gets customized by you.

Template-Toolkit is used to render the output.  The template
is included below the program code in the __DATA__ section.
A Template-Toolkit "filter" is created to highlight terms in
the description.  The filter uses the same modules that the swish.cgi
script uses for highlighting.

The template can be placed in its own file if you like.  That's the normal
way templates are used.  It's in the __DATA__ section in this script so that
only one file is needed.  If you run under mod_perl or SpeedyCGI you must
use a separate template file.

The index file is hard-coded as index.swish-e.  Change it as needed.
The script uses page numbers instead of record numbers.  Record
numbers might be more flexible.

This script can be run under SpeedyCGI by changing the top line to:

    #!/usr/bin/speedy -w

and installing SpeedyCGI, of course.  When run under SpeedyCGI
or mod_perl the template must be moved out into a separate file.
Set the INCLUDE_PATH to the directory where you store the
template file.

The script can also be run as a mod_perl handler.  If you use mod_perl
you might want to use Apache::Request instead of CGI.pm.

=head1 USAGE

The script is installed when Swish-e is installed.  On unix-like systems
this will like be at /usr/local/lib/swish-e/search.cgi.  If you used a
different --prefix option at compile time then it would be wise to look
there, instead.  Windows users will find the program someplace similar, but
different.  If installed as part of your OS distribution then it might be in
/usr/lib/swish-e.

Install the required modules (see next section) and then copy or symlink
the program to where you normally run CGI scripts.  Use .htaccess or whatever
your web server requires to indicate that the script is indeed a CGI script.

Create an index.  If the index is not in the current working directory when
the script is run, and is not called "index.swish-e" (the default swish-e index name)
then modify the script to find the correct index file.

Testing CGI script from the command line first will impress your friends.

The script is lightly commented so that hopefully you can understand how it works
and thus understand how to add the features you need.

=head1 REQUIREMENTS

To use this script as-is a few Perl modules will need to be installed.
You are not required to use these modules, but I like them and thus
I'm recommending that you give them a try.

=over 4

=item Template-Toolkit

Template-Toolkit (or TT) is available from CPAN or from

    http://search.cpan/org/
    http://tt2.org/

TT is used to generate the HTML output.  It's good code design to separate the
output generation from the "model" code that does the work of fetching the data.

I'm a big fan of Template-Toolkit.  It's simple enough that it's easy to learn
how to work with basic templates.  It's also not limiting and provides power to do what's
needed in the template without requiring too much setup in the logic part of your
code.  Note in the code how TT works directly with the objects returned by SWISH::API.
TT's dot notation means that you can change the backend data (e.g. from a hash to an object)
and the template does not need to change.

Please give TT a try.  It's a much better use of your time than writing Yet Another
Homemade Templating System.

=item HTML::FillInForm

This module is also available from CPAN

    http://search.cpan.org/

HTML::FillInForm makes HTML forms "sticky" -- that is, it takes previous data from
a CGI request and fills in the form elements.  What this means is you can write very
plain, basic HTML forms in the template and HTML::FillInForm will make them sticky.

The other way to have sticky forms is to use the CGI.pm module (which can be used directly
with Template-Toolkit).  Besides requiring that the large CGI.pm module gets loaded, it
means there's more programming-like code in the template, which should really just be
basic HTML, and means the template writer needs to also learn a little more Perl.


=back

=head1 SUPPORT

Not much support is provided.  But what support is provided is ONLY provided via
the Swish-e discussion list.

    http://swish-e.org/


=head1 AUTHOR

Bill Moseley

=head1 LICENSE

Copyright 2003 Bill Moseley.  All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=head1 SEE ALSO

SWISH::API,  Template, HTML::FillInForm
